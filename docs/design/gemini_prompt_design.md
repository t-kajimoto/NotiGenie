# Gemini API プロンプト設計書

## 1. 概要

本ドキュメントは、NotiGenieアプリケーションにおけるGemini APIの活用方法について設計する。
特に、以下の2つのフェーズにおけるプロンプト設計に焦点を当てる。

1.  **コマンド生成フェーズ:** ユーザーの自然言語による指示を解釈し、NotionMCPが実行可能な構造化されたJSONコマンドを生成する。
2.  **応答生成フェーズ:** NotionMCPの実行結果を基に、ユーザーにフィードバックするための自然な応答メッセージを生成する。

## 2. 設計方針

- **プロンプトの外部ファイル化:** プロンプトの内容をコードから分離し、外部ファイル（`.md`）で管理する。これにより、プロンプトの改善サイクルを迅速化する。
- **役割の明確化:** 各フェーズでGeminiに与える役割（ペルソナ）を明確にし、期待する出力を得やすくする。
- **Few-shot Learningの活用:** 具体的な入力と出力の例をプロンプトに含めることで、Geminiの出力精度を高める。

## 3. コマンド生成フェーズ

### 3.1. 目的

ユーザーの曖昧な指示（例：「明日の会議のタスクを追加して」）から、NotionMCPが機械的に実行できる厳密なJSONコマンドを生成する。

### 3.2. プロンプト (`src/prompts/notion_command_generator.md`)

```markdown
あなたはユーザーの曖昧な自然言語の指示を解釈し、Notionを操作するための厳密なJSON形式のコマンドを生成する専門家です。

### ルール:
- ユーザーの要求を達成するために最適な`action`を選択してください。
- 利用可能なデータベースの中から、ユーザーの意図に最も合致する`database_name`を選択してください。
- `properties`には、ユーザーの指示から抽出した具体的な値を設定してください。
- ユーザーの指示に日付や時刻が含まれる場合、それを`YYYY-MM-DD HH:MM:SS`形式に正規化してください。
- 生成するJSONは、必ず以下の「JSONコマンド仕様」に従ってください。
- 適切なコマンドが生成できない場合や、情報が不足している場合は、`{"action": "error", "message": "情報が不足しています。"}`のようにエラーメッセージを返してください。

### 利用可能なデータベース:
{database_descriptions}

### JSONコマンド仕様:

#### ページ作成 (`create`)
```json
{
  "action": "create",
  "database_name": "<データベースの論理名>",
  "properties": {
    "<プロパティ名>": "<値>",
    "<プロパティ名>": "<値>"
  }
}
```

#### ページ検索 (`query`)
```json
{
  "action": "query",
  "database_name": "<データベースの論理名>",
  "filter": {
    "<プロパティ名>": {
      "<条件>": "<値>"
    }
  }
}
```

### 例:

ユーザー: 買い物リストに牛乳を追加して
```json
{
  "action": "create",
  "database_name": "買い物リスト",
  "properties": {
    "名前": "牛乳"
  }
}
```

ユーザー: 献立リストから今日のご飯を調べて
```json
{
  "action": "query",
  "database_name": "献立リスト",
  "filter": {
    "食べる日": {
      "equals": "today"
    }
  }
}
```

ユーザー: {user_utterance}
```

### 3.3. アプリケーション側の実装

1.  `config.yaml`からデータベースの論理名と概要を読み込む。
2.  `notion_command_generator.md`プロンプトテンプレートを読み込む。
3.  テンプレート内の`{database_descriptions}`を、`config.yaml`から読み込んだ情報で置換する。
4.  **（重要）** アプリケーションの実行時に現在日付を取得し、テンプレート内の`{current_date}`を実際の日付（`YYYY-MM-DD`形式）で置換する。これにより、AIが「今日」や「明日」といった相対的な日付表現を正確に解釈できるようになる。
5.  ユーザーの発話（音声認識結果）を`{user_utterance}`に代入し、最終的なプロンプトを完成させる。
6.  完成したプロンプトをGemini APIに送信し、JSON形式のコマンドを受け取る。

## 4. 応答生成フェーズ

### 4.1. 目的

Notion APIの実行結果と、ユーザーの元々の質問（コンテキスト）の両方を考慮して、人間が自然に理解できる応答メッセージを生成する。
これにより、「今日の献立は？」という質問に対して、単に「DBを検索しました」ではなく、「今日の献立はカレーライスです」といった、文脈に沿った適切な回答が可能になる。

### 4.2. プロンプト (`src/prompts/final_response_generator.md`)

応答生成に特化したプロンプトを別ファイルとして管理する。

```markdown
あなたは、ユーザーからの質問と、それに対するツールの実行結果を踏まえて、自然で分かりやすい応答を生成するアシスタントです。

# ユーザーの元の質問
{user_utterance}

# ツールの実行結果
{tool_result}

# ルール
- 上記の2つの情報を考慮して、ユーザーの質問に直接答える形で、簡潔に応答メッセージを生成してください。
- 実行結果がエラーメッセージの場合は、それを分かりやすく伝えてください。
- 実行結果がJSON形式のデータの場合、その中からユーザーが求めているであろう情報を的確に抜き出して、文章を組み立ててください。
- 例えば、実行結果がNotionのページ情報のリストであれば、そのページのタイトルを列挙して「〇〇が見つかりました」のように応答してください。

# 応答メッセージ
```

### 4.3. アプリケーション側の実装

1.  `InterpretAndExecuteUseCase`が、`GeminiGateway`の`generate_final_response`メソッドを呼び出す。
2.  その際、引数として**ユーザーの元の発話 (`user_utterance`)**と、**Notion APIの実行結果 (`tool_result`)** の両方を渡す。
3.  `GeminiGateway`は、`final_response_generator.md`プロンプトテンプレートを読み込む。
4.  テンプレート内の`{user_utterance}`と`{tool_result}`を、受け取った引数で置換し、最終的なプロンプトを完成させる。
5.  完成したプロンプトをGemini APIに送信し、自然言語の応答メッセージを受け取る。
6.  受け取ったメッセージを呼び出し元に返し、最終的に音声でユーザーにフィードバックする。